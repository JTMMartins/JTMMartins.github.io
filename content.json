{"meta":{"title":"JoseMartins","subtitle":"Make it correct, make it clear, make it concise, make it fast. In that order.","description":"a Java blog","author":"José Martins","url":"https://jtmmartins.github.io"},"pages":[],"posts":[{"title":"Parameterized unit tests with JUnit 4","slug":"Parameterized-unit-tests-with-Junit-4","date":"2019-10-26T20:10:22.000Z","updated":"2019-10-28T00:21:46.367Z","comments":true,"path":"2019/10/26/Parameterized-unit-tests-with-Junit-4/","link":"","permalink":"https://jtmmartins.github.io/2019/10/26/Parameterized-unit-tests-with-Junit-4/","excerpt":"","text":"If you are a governed by conscience developer, you write tests, period. As any piece of code, well written tests should be clear, concise, easy to maintain and actually test something. As everything in life, those skills come with experience. Today we will talk about parameterized unit tests, as they provide ways of making your unit test development more complete, less tedious, more readable and much easier to maintain. It is worth noticing that JUnit 4 has not chosen a very flexible approach to parametrized tests. They improved significantly in JUnit 5 (which I will visit in a future post). If you aim for the maximum power and flexibility, then you should take a look to JUnitParams (I will also visit this JUnit addon in a future post). What kind of problems does a Parameterized Unit Test solves ?You are aware of the DRY principle, however if you are not yet using parameterized tests, you may have found yourself in situations where you have to repeat the same code across several tests methods just to assert some outcome, based on a situation where only one field of the same object changes. That is precisely the problem solved by parameterized tests. Let’s create a small, but illustrative problem and see how we can benefit from a parameterized unit test. This is not a post about TDD, so if you are a unit test purist, please accept my apologies for the “code first” approach and for the lack of null checks. We have a Purchase Purchase.java1234567@AllArgsConstructorpublic class Purchase &#123; private final long id; @Getter private PurchaseStatus status;&#125; The purchase can have 4 different statuses that are enumerated PurchaseStatus.java123456public enum PurchaseStatus &#123; CONFIRMED, COMPLETED, FAILED, PENDING;&#125; We need to process the purchases. For the purpose we have a purchaseJob that will do the work.As long as the purchase has a COMPLETED status it will be processed and for all the other statuses it will not. In our example, we just return true or false, depending on the Purchase status. PurchaseJob.java12345678public class PurchaseJob &#123; public boolean process(final Purchase purchase) &#123; return PurchaseStatus.COMPLETED.equals(purchase.getStatus()); &#125;&#125;&#125; So, what can we see from the code ? A purchase can arrive to the method process() with any of the 4 possible status. Depending on that status things will happen (although here as example, the only thing happening is returning a boolean). We easily realize that if we want to test all the 4 possibilities we will have to write 4 test methods, however the only thing that changes is the status field of the purchase. There is a better way, and lets go directly to it. We start by creating a pretty standard unit test to deal with the positive outcome PurchaseJobProcessPositiveTest.java1234567891011121314151617public class PurchaseJobProcessPositiveTest &#123; private PurchaseJob purchaseJob; private Purchase purchase; @Before public void setUp()&#123; purchaseJob = new PurchaseJob(); purchase = new Purchase(1L, PurchaseStatus.COMPLETED); &#125; @Test public void processPurchase_returnsTrue()&#123; Assert.assertTrue(purchaseJob.process(purchase)); &#125;&#125; If we where to create methods to test all the 4 possibilities, then we will need to write 3 additional @test methods, where the only difference amongst them would be the status of the Purchase Object.Imagine if we had 10 different statuses, or even if the process() method received 2 parameters, each with a couple of different possible status. When we encounter this kind of situations, we can take advantage of parameterized tests. We will do so to handle the negative outcomes. PurchaseJobProcessNegativeTest.java12345678910111213141516171819202122232425262728@RunWith(Parameterized.class)public class PurchaseJobProcessNegativeTest &#123; @Parameterized.Parameters public static Iterable&lt;? extends Object&gt; dataProvider() &#123; final Purchase purchaseConfirmed = new Purchase(1L, PurchaseStatus.CONFIRMED); final Purchase purchaseFailed = new Purchase(2L, PurchaseStatus.FAILED); final Purchase purchasePending = new Purchase(3L, PurchaseStatus.PENDING); return Arrays.asList(purchaseConfirmed, purchaseFailed, purchasePending); &#125; private PurchaseJob purchaseJob; @Parameterized.Parameter(0) public Purchase purchase; @Before public void setUp() &#123; purchaseJob = new PurchaseJob(); &#125; @Test public void processPurchase_returnsFalse() &#123; Assert.assertFalse(purchaseJob.process(purchase)); &#125;&#125; Let’s dissect what we have. We start by annotating the class with @RunWith(Parameterized.class) to ensure that JUnit will invoke the referenced class to run the tests instead of the default runner built into JUnit (see JUnit-runWith-JavaDoc) The second step is to create a public static method annotated with @Parameterized.Parameters that returns a Collection of object arrays. I’ve used the Iterable interface which is the root interface in the collection hierarchy, but we could have chosen to return a List &lt;Purchase&gt; and, in our case, it would work without any problems. The objects that are part of the collection returned from this dataProvider() method are the ones that will be supplied to all the test methods in the class. Although not practical, in JUnit4 that’s how it works. The test methods will run as many times as the number of objects present in the collection. In other words, the runner will iterate trough each @test method as many times as the number of objects in the collection, and in every iteration one object from that collection will be supplied. Bear in mind that, had we included the positive test method in this class, the test would continue to pass, as we are forcing the purchase to be in a COMPLETE status manually, however this positive test method would run 3 times, which is a completely waste of time and resources. The final step is the not mandatory @Parameterized.Parameter(0). The advantage of this annotation is that it will handle the injection of the parameter for us, therefore we do not need a constructor for the test class. If we choose not to use this annotation, then we will have to provide a constructor for the test class. Note the number zero in the annotation. It is also not mandatory as it always defaults to zero and if you just type @Parameterized.Parameter no one will complaint.I prefer to use it (although some IDE’s might complaint), to be explicit that is the object present in the first array column. This means, obviously that we can have more than one parameter being supplied, and we will annotate their respective fields with @Parameterized.Parameter(1), @Parameterized.Parameter(2), and so forth, according to the column they live in the array. pros : We only have one test method that covers 3 possible status. If one day we need to add a new status, we just need to add the purchase to the data() method. It’s small, clean and readable. Executes faster than 3 methods, due to the way JUnit handles the work internally. and now for the cons : We should have one parameterized test class per method of the UUT (unit under test). (JUnit 5 solves this). We can achieve the same results with less code by adding JUnitParams library to our projects. I hope this little example is useful, and drives your curiosity to explore more about JUnit. Happy coding :)","categories":[{"name":"Testing","slug":"Testing","permalink":"https://jtmmartins.github.io/categories/Testing/"},{"name":"Junit 4","slug":"Testing/Junit-4","permalink":"https://jtmmartins.github.io/categories/Testing/Junit-4/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"https://jtmmartins.github.io/tags/Testing/"},{"name":"Junit 4","slug":"Junit-4","permalink":"https://jtmmartins.github.io/tags/Junit-4/"}]},{"title":"06 - The consumer Interface","slug":"lambda-expressions-part-six","date":"2018-04-30T22:29:41.000Z","updated":"2018-05-01T22:35:40.000Z","comments":true,"path":"2018/04/30/lambda-expressions-part-six/","link":"","permalink":"https://jtmmartins.github.io/2018/04/30/lambda-expressions-part-six/","excerpt":"“Whatever goes in, never comes out” could be the Hollywood movie line to define a consumer, which is no more than a function that receives an argument, consumes it and returns nothing.","text":"“Whatever goes in, never comes out” could be the Hollywood movie line to define a consumer, which is no more than a function that receives an argument, consumes it and returns nothing. In this article I will talk about the Consumer functional Interface. Being a functional interface means it can be used as target type for lambda expressions. A consumer is quite easy to explain. It is used whenever we need an object to be consumed. Consumed in this context means that a function receives an object as an input argument, eventually applies some kind of operation to that object, but nothing is returned from that function. In this cases, we say that the object has been consumed. Let’s take a quick look to the Consumer interface source code, java.util.function.Consumer.java12345678@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; The abstract method accept(), is responsible for receiving the object, performing whatever operation is defined in the lambda expression, and returns no value.The andThen() method is a little more trickier. When applied, it returns a new consumer which represents the aggregation of both operations defined in both consumers. We can write a quick example to demonstate the Consumer accept() ConsumerExampleOne.java12345678910111213141516public class ConsumerExampleOne &#123; public static void main(String[] args) &#123; Consumer&lt;Integer&gt; consumer=x-&gt;System.out.println(x); List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5); for(Integer n:integerList) &#123; print(n,consumer); &#125; &#125; public static void print(Integer n,Consumer&lt;Integer&gt; consume) &#123; consume.accept(n); &#125;&#125; in the above example, the Consumer, is passed to the print() method together with an Integer and then just print’s the value. We can also observe the behaviour of the andThen() method from the Consumer Interface, which combines two expressions, ConsumerExampleTwo.java1234567891011121314151617public class ConsumerExampleTwo &#123; public static void main(String[] args) &#123; List&lt;String&gt; wordList = Arrays.asList(\"Al\", \"Bc\", \"Cs\", \"Dr\", \"Ft\"); Consumer&lt;String&gt; consumer1 = x -&gt; System.out.println(\"consumer One :\" + x.toLowerCase()); Consumer&lt;String&gt; consumer2 = x -&gt; System.out.println(\"Consumer Two :\" + x.toUpperCase()); for (String w : wordList) &#123; print(w, consumer1, consumer2); &#125; &#125; public static void print(String s, Consumer&lt;String&gt; consumerOne, Consumer&lt;String&gt; consumerTwo) &#123; Consumer&lt;String&gt; combinedConsumer = consumerOne.andThen(consumerTwo); combinedConsumer.accept(s); &#125;&#125; When run the above code will print,consumer One :alconsumer Two :ALconsumer One :bcconsumer Two :BCconsumer One :csconsumer Two :CSconsumer One :drconsumer Two :DRconsumer One :ftconsumer Two :FTTwo consumers are created, consumer1 and consumer2. Both are dispatched to the print() method where they are combined originating the combinedConsumer reference. When the the accept() method is called on the combinedConsumer both operations defined in the consumer1 and consumer2 are applied. A better example than just print somethingAs mentioned above, a consumer, can apply any transformation we want to an object. In the next example, we simulate a bank that charges a service fee every time a customer makes a deposit with a value lower than 200. We can use a combination of a predicate and a consumer to handle the job, the Account class Account.java1234567891011121314151617181920212223public class Account &#123; private int accountNumber; private double AccountBalance; public Account(int accountNumber, double InitialDeposit) &#123; this.accountNumber=accountNumber; this.AccountBalance=InitialDeposit; &#125; public int getAccountNumber() &#123; return accountNumber; &#125; public void setAccountNumber(int accountNumber) &#123; this.accountNumber = accountNumber; &#125; public double getAccountBalance() &#123; return AccountBalance; &#125; public void setAccountBalance(double accountBalance) &#123; AccountBalance = accountBalance; &#125;&#125; The AccountProcessor Class AccountProcessor.java12345678910111213141516171819import java.util.function.Consumer;import java.util.function.Predicate;public class AccountProcessor &#123; public void deposit(Account account,double amount,Predicate&lt;Double&gt; lowValueDeposit,Consumer&lt;Account&gt; consumer) &#123; if (lowValueDeposit.test(amount)) &#123; consumer.accept(account);//it is a low deposit, reduce fee from balance. System.out.println(\"Deposit Fee applied to account Number \"+ account.getAccountNumber()); &#125;else &#123; System.out.println(\"No deposit Fee applied\"); &#125; account.setAccountBalance(account.getAccountBalance()+amount); &#125; public void printBalance(Account account) &#123; System.out.println(account.getAccountBalance()); &#125;&#125; And the App that will do some work, App.java123456789101112131415161718192021222324import java.util.function.Consumer;import java.util.function.Predicate;public class App &#123; public static void main(String[] args) &#123; Account accountOne = new Account(1, 0); Account accountTwo = new Account(2, 0); Account accountThree = new Account(3, 0); Predicate&lt;Double&gt; isLowDeposit = x -&gt; x &lt; 200; Consumer&lt;Account&gt; lowDepositServiceFee = acc -&gt; acc.setAccountBalance(acc.getAccountBalance() - 2.50); AccountProcessor accountProcessor = new AccountProcessor(); accountProcessor.deposit(accountOne, 201.0, isLowDeposit, lowDepositServiceFee); accountProcessor.deposit(accountTwo, 180.0, isLowDeposit, lowDepositServiceFee); accountProcessor.deposit(accountThree, 80.0, x -&gt; x &lt; 200, acc -&gt; acc.setAccountBalance(acc.getAccountBalance() - 2.50)); accountProcessor.printBalance(accountOne); accountProcessor.printBalance(accountTwo); accountProcessor.printBalance(accountThree); &#125;&#125; When run it prints,No deposit Fee appliedDeposit Fee applied to account Number 2Deposit Fee applied to account Number 3201.0177.577.5Most of the above example is code just to make the simulation run. The relevant stuff for the example is the lowDepositServiceFee Consumer and the isLowDeposit Predicate references that are created in line 12 and 13 and later passed to the accountProcessor.deposit() method. This is where the predicate and the consumer do their magic in line 7 and line 8. Obviously this only works as an example, so if you do own a bank do not use this, as we are not even checking if the deposit is not negative !!! :) Also note that in line 18, instead of passing the isLowDeposit reference, we passed the lambda expression directly, just to show that it also can be done in that way. In the next post I will talk about the Supplier interface. ‘till then happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"05 - The Predicate Interface","slug":"lambda-expressions-part-five","date":"2018-04-25T19:12:11.000Z","updated":"2018-04-25T22:37:57.000Z","comments":true,"path":"2018/04/25/lambda-expressions-part-five/","link":"","permalink":"https://jtmmartins.github.io/2018/04/25/lambda-expressions-part-five/","excerpt":"A predicate can be understood as a function that returns a value that is either true or false. The proper use of it can make your code easier to maintain.","text":"A predicate can be understood as a function that returns a value that is either true or false. The proper use of it can make your code easier to maintain. Although Predicate shines more when used together with streams, we can actually use it in every situation where we weed to evaluate if an expression returns true or false. As I have the intention to create a series of posts dedicated exclusively to the streams.api, I’ve been trying to keep streams away from the posts in this lambda series, and this one will be no exception, although the temptation is strong. First let’s see what we have in the source code of the Predicate interface, java.util.function.Predicate.java123456789101112131415161718192021222324@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t); default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; A quick glance at the code reveals almost immediately what it does.test() returns a boolean and is the abstract method and will define the signature of the lambda expression reference which can be assigned to a Predicate and() together with or() appear to do the combinatory logic between two predicate functions, negate() as the name implies negates a predicate and isEqual(), is self-explanatory. To ensure if this works as expected, lets write a quick example, App.java12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class App &#123; public static void main(String[] args) &#123; Predicate&lt;Integer&gt; onlyOddNumbers = i -&gt; !(i % 2 == 0); List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 5, 8, 6, -13, 9); Print(filter(integerList, onlyOddNumbers)); &#125; public static void Print(List&lt;Integer&gt; listToPrint) &#123; listToPrint.forEach(System.out::println); &#125; public static List&lt;Integer&gt; filter(List&lt;Integer&gt; originalList, Predicate&lt;Integer&gt; predicate) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (Integer i : originalList) &#123; if (predicate.test(i)) &#123; result.add(i); &#125; &#125; return result; &#125;&#125; We define a Predicate onlyOddNumbers to evaluate if a number is odd or even. We then pass that predicate to the filter() method together with a list of Integers testing all the elements of the list against that predicate while storing the elements that evaluate as true. Then we print the result. When run, it prints15-139 Great…How about combining predicates ? Let’s add a combined Predicate to our app, and see how it goes, App.java12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class App &#123; public static void main(String[] args) &#123; Predicate&lt;Integer&gt; onlyOddNumbers = i -&gt; !(i % 2 == 0); Predicate&lt;Integer&gt; onlyPositives = i-&gt; i &gt; 0; //combined predicate Predicate&lt;Integer&gt; positivesAndEven=onlyOddNumbers.and(onlyPositives); List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 5, 8, 6, -13, 9); Print(filter(integerList, positivesAndEven)); &#125; public static void Print(List&lt;Integer&gt; listToPrint) &#123; listToPrint.forEach(System.out::println); &#125; public static List&lt;Integer&gt; filter(List&lt;Integer&gt; originalList, Predicate&lt;Integer&gt; predicate) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (Integer i : originalList) &#123; if (predicate.test(i)) &#123; result.add(i); &#125; &#125; return result; &#125;&#125; This code is similar to the previous one. We just added a second Predicate named onlyPositives and combined it with onlyOddNumbers in positivesAndEven. As before, we passed this combinatory predicate to the filter() method and then we printed the result. When run it prints159 The negative value is gone, filtered by the onlyPositives predicate. In this particular case if we apply or() to combine both predicates we will get all the values from the initial list, due to the fact that an OR operation only returns true when both operands are false (false V false = false). However if we change the value in integerList from -13 to -12, then we won’t get the negative value, as it is negative and even so an OR operation will return false and the value will not be added to the result list. There isn’t much to say about the negate() or equals(). The first will return the inverse of the Predicate, and the former will compare two objects for equality. As I mentioned earlier, predicates do shine brighter when used with streams, and I will go into that, as time allows. The next post in this lambda series will be about the Consumer interface. ‘till then happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"04 - Function Composition","slug":"lambda-expressions-part-four","date":"2018-04-25T10:49:27.000Z","updated":"2018-04-26T11:16:39.000Z","comments":true,"path":"2018/04/25/lambda-expressions-part-four/","link":"","permalink":"https://jtmmartins.github.io/2018/04/25/lambda-expressions-part-four/","excerpt":"Function composition is the ability to create simple and reusable functions that can be combined in order to create more complex functions. Java made this easy","text":"Function composition is the ability to create simple and reusable functions that can be combined in order to create more complex functions. Java made this easy In the programming world, the process of function composition is also known as currying in honour of Haskell Brooks Curry, an American mathematician well known for his work in the combinatory logic field. Although the words “combinatory logic” are enough to deliver us a panic attack, Java actually made this an easy process. Let’s see how it works. The Function interface has two methods that allow us to compose functions. The andThen and compose methods. Let’s take a quick look to the Function interface source code from the java.util.function java.util.function.Function.java123456789101112131415161718@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; I have to be honest, the first time I saw the signature of andThen() and compose() methods, I had to go back and read this a few times. If you feel like I did, well, just take a peek to the article to refresh your Generics. The andThen() method is combining the current function with another function named after. But this is done in a way that the first function is applied and the input type T is converted to type R. After that the after function is applied and converts the type R to type V. In simpler words the andThen() method applies both functions and also converts the type T to type V. The compose() method is quite similar in the away it works, however it inverts the order of how the functions are applied. Let’s see a quick example.(please note that I’m not using streams, because this series is about lambda expressions and the objective is to train our brain in creating functions, even if they look weird :) . app.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Function;public class App &#123; static Function&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; doubleNumbersFunc; static Function&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; squareNumbersFunc; static Function&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; composedFunctionWithAndThen; static Function&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; composedFunctionWithCompose; static &#123;// first static block doubleNumbersFunc = numbers -&gt; &#123; List&lt;Integer&gt; rethey aresult = new ArrayList&lt;&gt;(); for (Integer i : numbers) &#123; result.add(i * 2); &#125; return result; &#125;; &#125; static &#123;// Second static block squareNumbersFunc = numbers -&gt; &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (Integer i : numbers) &#123; result.add(i * i); &#125; return result; &#125;; &#125; static &#123;//third static block composedFunctionWithAndThen=doubleNumbersFunc.andThen(squareNumbersFunc); composedFunctionWithCompose=doubleNumbersFunc.compose(squareNumbersFunc); &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 5, 9); System.out.println(\"AndThen Result :\" + composedFunctionWithAndThen.apply(list)); System.out.println(\"Compose Result :\" + composedFunctionWithCompose.apply(list)); &#125;&#125; when run, this code prints AndThen Result :[4, 16, 100, 324]Compose Result :[2, 8, 50, 162] So what is happening ? First the functions are initialized in static blocks. In the first static block we define the function doubleNumbersFunc. It receives a list of Integers, multiplies each value by 2 and returns a list with the result. In the first static block we define the function squareNumbersFunc. It receives a list of Integers, squares each number and returns a list with the result. The third block is the fancy one. We create the composed functions composedFunctionWithAndThen using the andThen() method and the composedFunctionWithCompose using the compose() method. in the main method, we print the apply() of each of the combined functions. As you can see, the result is different. This happens because andThen() applies the functions from left to right and compose() applies the functions from right to left. in the above example this is how the andThen() worked, and this is how the compose() worked, The process is very straightforward, but we need extra care if we start assembling functions with nested andThen() and compose(). The last one in the Function interface is the identity(). This method’s mission is very simple. It just returns back the parameter which it gets as input. Usually the use of identity() is not to modify a value that has arrived to a function, and its usefulness becomes more obvious when used in conjunction with the java.util.stream.api. In the next post I will look into another Functional interface. The Predicate. Don’t get upset. It’s only the programmers jargon for something that evaluate if a condition is true or false. ‘till then happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"03 - The Function Interface","slug":"lambda-expressions-part-three","date":"2018-04-23T11:23:43.000Z","updated":"2018-04-25T10:32:58.000Z","comments":true,"path":"2018/04/23/lambda-expressions-part-three/","link":"","permalink":"https://jtmmartins.github.io/2018/04/23/lambda-expressions-part-three/","excerpt":"It’s now time to slowly start to elaborate and dig deeper in the particular aspects of functions in Java. The language developers made our life easier.","text":"It’s now time to slowly start to elaborate and dig deeper in the particular aspects of functions in Java. The language developers made our life easier. Our first problem is easy. We want a function that returns the square of a value, like &int;(x)=x2 As we’ve seen in the introductory posts, we need a type, so we will start by writing the functional interface SimpleFunction. SimpleFunction.java1234@FunctionalInterfacepublic interface SimpleFunction &#123; public int get(int n);&#125; our interface has an abstract method, that receives an int (this is how we pass values to functions) and returns a int. With what we learned in the first and second post, we can now easily write a small program to print the square of a number by using a lambda expression, App.java1234567public class App &#123; public static void main(String[] args) &#123; SimpleFunction square=a-&gt;a*a; System.out.println(square.get(5)); &#125;&#125; Nothing fancy here. We created the variable square of the type SimpleFunction and assign a little code to it, in the form of a lambda expression. If you remember the first post of the series, you might now be saying… Wait…where are the parenthesis ? Shouldn’t we have written (a)-&gt; return a*a ? In the first post, we introduced rule number 1, now we are going to introduce 2 more rules, Rule number 2 If we are passing only one argument to a function, then the parenthesis are optional. Rule number 3 If the block of code is condensed to one line, the return keyword MUST be ommited. Ok. I get it, but it seems quite boring to write an functional Interface every time we want to create a lambda expression. Indeed it is, and we don’t need to do that. Let’s focus on the get method of the SimpleFunction interface. It receives an int as argument and returns an int value. It looks like we can re-use that interface for any function that follows that pattern. If we try the following code where the function returns the double of a value &int;(x)=2x , it still is perfectly valid, App.java1234567public class App &#123; public static void main(String[] args) &#123; SimpleFunction twice=a-&gt;a+a; System.out.println(twice.get(5)); &#125;&#125; If you know Generic types, some bells are probably starting to ring… what if we change our interface to, SimpleFunction.java1234@FunctionalInterfacepublic interface SimpleFunction &lt;T&gt;&#123; public T get (T n);&#125; Now we can reuse this interface for objects of any class, App.java12345678910public class App &#123; public static void main(String[] args) &#123; SimpleFunction&lt;Double&gt; square=a-&gt;a*a; System.out.println(square.get(5.0)); SimpleFunction&lt;String&gt; firstChar=s-&gt;s.substring(0, 1); System.out.println(firstChar.get(\"Lambda\")); &#125; Luckily Java creators where kind enough to include the java.util.Function library, which is packed with functional interfaces for the most common programming tasks, so unless we deal with some very special type of problems, this library will serve us well, and we will not need to create our own interfaces. Some of them are quite important, and, as time allows, I will try to cover them across the posts in this series. The Function interface1Function &lt;T,R&gt; interface Function is one of the included functional interfaces in the java.util.Funcion library. The Function interface has one abstract method, R apply(T t); This means that T represents the generic type of the argument entering into the function and R represents the generic type of the object coming out of the function (the return type). We will change our code, so that it uses the Function interface instead of our own. App.java12345678public class App &#123; public static void main(String[] args) &#123; Function&lt;Integer, Integer&gt; square=a-&gt; a*a; System.out.println(square.apply(10)); Function&lt;String, String&gt; firstChar=s-&gt;s.substring(0, 1); System.out.println(firstChar.apply(\"Hello\")); &#125; The Function Interface is a good one to start playing with functions, passing actions to methods and understand how all this works. The final example for today, will be something a little more elaborate, and a good training. Problem-We have a list of person Objects. We need a method to print the person name according to a filter that should be passed to that method. We can not use Streams. To solve this problem, the first thing we need, is the Person class, Person.java1234567891011121314151617181920212223242526272829public class Person &#123; private String name,region; private int age; public Person(String name, int age, String region) &#123; this.name=name; this.region=region; this.age=age; &#125; //getters &amp; setters public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getRegion() &#123; return region; &#125; public void setRegion(String region) &#123; this.region = region; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; By using everything we’ve learned so far we can now create a PersonFilteredReportService class (remember we can not use streams as the problem stated), PersonFilteredReportService.java12345678910111213141516171819202122import java.util.ArrayList;import java.util.List;import java.util.function.Function;public class PersonFilteredReportService &#123; public List&lt;Person&gt; filter(List&lt;Person&gt; persons, Function&lt;Person, Boolean&gt; filter) &#123; List&lt;Person&gt; filteredList=new ArrayList&lt;&gt;(); for (Person p : persons) &#123; if (filter.apply(p)) &#123; filteredList.add(p); &#125; &#125; return filteredList; &#125; public boolean print(List&lt;Person&gt; personList) &#123; for(Person p:personList) &#123; System.out.println(p.getName()); &#125; return true; &#125;&#125; To check if this is working, we should create a unit test, but for the sake of simplicity we will code a small application with 2 different filters. One will filter by region and other will filter by age. App.java123456789101112131415161718192021222324import java.util.Arrays;import java.util.List;import java.util.function.Function;public class App &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = Arrays.asList( new Person(\"John\", 27, \"Lisbon\"), new Person(\"Peter\", 12, \"Faro\"), new Person(\"Mary\", 42, \"Porto\"), new Person(\"Richard\", 31, \"Castelo Branco\"), new Person(\"Terry\", 19, \"Braga\"), new Person(\"Anne\", 39, \"Porto\")); // Defining 2 different filters using lambda expressions Function&lt;Person, Boolean&gt; filterByRegion = p -&gt; p.getRegion().equals(\"Porto\"); Function&lt;Person, Boolean&gt; filterByAge = p -&gt; p.getAge() == 12; PersonFilteredReportService personReportService = new PersonFilteredReportService(); // Passing the lambda expression directly to the print method personReportService.print(personReportService.filter(persons, filterByRegion)); personReportService.print(personReportService.filter(persons, filterByAge)); &#125;&#125; As you can see, the possibility of passing actions directly into methods executing them when needed, makes our code easier to understand, easier to maintain, promotes re-usability, makes the code more compact and organized…and we are only scratching the surface :) In the next post of this series we will introduce the concept of function composition. ‘till then happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"02 - The Functional Interface","slug":"lambda-expressions-part-two","date":"2018-04-22T14:49:22.000Z","updated":"2019-10-26T20:11:39.896Z","comments":true,"path":"2018/04/22/lambda-expressions-part-two/","link":"","permalink":"https://jtmmartins.github.io/2018/04/22/lambda-expressions-part-two/","excerpt":"In the first post of this easy introductory series we have introduced the basic foundations of how to form a lambda expression.It’s now time to learn how we can use them.","text":"In the first post of this easy introductory series we have introduced the basic foundations of how to form a lambda expression.It’s now time to learn how we can use them. We have already learned that the basic idea behind lambda expressions is to assign a block of code to a variable.As a variable can be passed, as an argument, to methods, this means that we can pass a block of code around, which will lead to the ultimate goal - passing behaviours around our application, without the need to create extra classes. Remember, functions live in isolation and they are entities in their own right. We finished the previous post by showing this piece of code, gentsSalutation= () -> System.out.println(“Hello dear sir”); and asking ourselves “What is the type of the gentsSalutation variable ?”, because as we know Java is a strong typed language, so all variables need to be assigned a type. The Functional InterfaceJava 8 brought us the concept of Functional Interfaces. By definition, “A Functional Interface is an Interface that contains one abstract method (a method with no implementation).there is an exception, mentioned below in the post The java.util.function Java 8 documentation, also states “Functional Interfaces provide target types for lambda expressions and method references”. By combining the above, we can then say that a functional interface is an interface with only one abstract method that provides a target type for lambda expressions. I will take the example from the previous post. We can see that an interface named salutation is already in place. Salutation.java123public interface Salutation &#123; public void perform();&#125; We have an Interface, which has only one method, and that method has no implementation, so it is abstract. It looks like we have a perfect candidate for the above definition and, as so, we are in the presence of a Functional Interface. So, if a Functional Interface can be a target type for a lambda expression, what will happen if we assign the Salutation type to our gentsSalutation variable ? Let’s fetch part of the the code we need from the previous post the Interface, Salutation.java123public interface Salutation &#123; public void perform();&#125; the Service, SalutationService.java123456public class SalutationService &#123; public void salute(Salutation salutation ) &#123; salutation.perform(); &#125;&#125; We also had the App class, but we will now change it to include our gentsSalutation variable as being of type Salutation App.java1234567891011public class App &#123; public static void main(String[] args) &#123; SalutationService salutationService=new SalutationService(); Salutation gentsSalutation=()-&gt;System.out.println(\"Hello dear sir\"); Salutation ladiesSalutation=()-&gt;System.out.println(\"Hello dear Madam\"); salutationService.salute(gentsSalutation); salutationService.salute(ladiesSalutation); &#125;&#125; The salute method of the SalutationService, was already accepting a Salutation object, and now our gentsSalutation variable has been assigned that same type, therefore it becomes possible to pass it as an argument to the method. When run, this code works perfectly and we get the same result as before, but now we are using the lambda expression. So, what happened here ? We got rid of the GentsSalutation and the Ladiessalutation classes. We created two expressions (function - which executes an action) and assigned them to the variables getsSalutation and ladiesSalutation. As variables can be passed around, we passed those variables to the service and there, the code was executed when we called .perform() on it. To clarify, let’s see what happens if we change our app class in a way that we do not use the service class, App.java12345678public class App &#123; public static void main(String[] args) &#123; Salutation gentsSalutation=()-&gt;System.out.println(\"Hello dear sir\"); gentsSalutation.perform(); &#125;&#125; When run, this code does exactly the same. So we can conclude that the lambda expression is actually acting as if it was an implementation of the interface and we could drop the SalutationService class if we wanted (although in my opinion, the presence of the service class makes things easier to understand). This is the reason why a Functional Interface can only have one abstract method see exception bellow. If you had more than one, then the compiler would not know which one would be related to the lambda expression. Java 8 also introduced the annotation @FunctionalInterface, which is to be used so that the compiler knows that an Interface is supposed to be Functional. It is not mandatory to use the annotation, however is good practice to do so, as it makes clear the nature of the interface. Also if someone changes the code in a way that it becomes a non functional interface, the compiler will immediately complaint about it, pointing us that the interface is not Functional. As we like to follow good practises, we change our interface to, Salutation.java1234@FunctionalInterfacepublic interface Salutation &#123; public void perform();&#125; Earlier we wrote “a functional interface is an interface with only one abstract method that provides a target type for lambda expressions”. ImportantHowever there is an exception. If we change our Salutation interface to, Salutation.java12345678910@FunctionalInterfacepublic interface Salutation &#123; public void perform(); @Override public String toString(); @Override public boolean equals(Object o);&#125; compiling and running the code, will not present any problems. This seems to be in contradiction to the Functional Interface definition. We clearly have 3 abstract methods in there. About Functional Interfaces what we need to retain is that abstract methods that override public methods in java.lang.Object do not count to the total of the abstract methods in the interface. Having said that, the above code mantains it’s integrity as a functional interface, as only the perform() method does not overrides public methods from java.lang.Object. In this and the previous post, we have looked into the very basics of lambda expressions. In the next post, we will start to create some more elaborated functions, ‘till then…happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"01 - The genesis of a lambda expression","slug":"lambda-expressions-part-one","date":"2018-04-21T21:58:44.000Z","updated":"2018-04-26T11:26:51.000Z","comments":true,"path":"2018/04/21/lambda-expressions-part-one/","link":"","permalink":"https://jtmmartins.github.io/2018/04/21/lambda-expressions-part-one/","excerpt":"In the first post of this series we will look at the basics of how a lambda expression is formed and what do they bring to the table.","text":"In the first post of this series we will look at the basics of how a lambda expression is formed and what do they bring to the table. My initial thoughtsJava 8 introduced us the exciting world of functional programming. For a long time my reaction to this, was “Ok..one day I will look into that”, as if it was some minor thing that wouldn’t bring anything important to my world. I was wrong. Recently I needed to study this “lambda things” due to the OCP exam, and as I studied and documented my learnings, I started to understand the importance of lambda expressions, and how my code could improve significantly by using them. It wasn’t an easy process, I must admit, as my head was formatted to think in an object oriented approach and functional programming is a completely new paradigm. I the next few posts, I will try to resume and organize the notes I took while studying and learning the subject. Please have in mind that I will not use streams in the examples through out this lambda series. I will cover streams in another series dedicated to the subject. Understanding “the why” lambda expressions.Up to Java 7 everything was an object. All the code was in someway “linked” to a class and all functionality was inside methods, which we could pass values or objects to, in order to perform some action. We couldn’t imagine something living in isolation (without belonging to a method in a class) that would create an action. To understand the reason behind the need for lambda expressions, I will start with a very small and very simple example in traditional Java code. Problem : The engineering team is building a camera that recognizes the gender of the persons.We want to create a service that can salute a person when she enters the building.Great that sounds easy..So let’s go. We start coding our service and we come up with SalutationService.java123456public class SalutationService &#123; public void salute() &#123; System.out.println(\"Hello dear sir\"); &#125;&#125; Our main app, its also very straightforward, so we code : App.java12345678public class App &#123; public static void main(String[] args) &#123; SalutationService salutationService=new SalutationService(); salutationService.salute(); &#125;&#125; Ok..We’ve done it. It runs and salutes the gentleman that comes into the building (here represented by printing a message to the console). But our code it’s quite stupid. What if a lady is entering the building ? Before our company gets sued by some organization for gender equality, we’ve better solve the problem and make sure that the camera, being built by our mates will work properly with our service. Now we have two options we can choose from. We could add an argument to our salute method in the SalutationService and, based on that, we could do an If statement or setup a case machine with a switch.But that is poor design and is driving us directly to a possible maintenance hell. Let’s suppose that later we want to salute children and eventually several genders of aliens, that in the mean time have arrived to Earth !! We will end up with a bunch of If statements, that will be difficult to maintain and expand. Or Go by the book, using an Object Oriented approach, to ensure that in future we can expand and maintain our code without many complications. As we are smart, we go for the second option. We follow the best practises, program for the interface and make use of polymorphism. We start by creating the Salutation interface, Salutation.java123public interface Salutation &#123; public void perform();&#125; then we create the GentsSalutation and LadiesSalutation classes, both implementing the Salutation interface, GentsSalutation.java1234567public class GentsSalutation implements Salutation &#123; @Override public void perform() &#123; System.out.println(\"Hello dear sir\"); &#125;&#125; LadiesSalutation.java1234567public class LadiesSalutation implements Salutation &#123; @Override public void perform() &#123; System.out.println(\"Hello dear Madam\"); &#125;&#125; Ok…We are getting there…Now we need to change our SalutationService, so it becomes, SalutationService.java123456public class SalutationService &#123; public void salute(Salutation salutation ) &#123; salutation.perform(); &#125;&#125; Finally we adapt our app class to reflect the changes, so it becomes App.java123456789public class App &#123; public static void main(String[] args) &#123; SalutationService salutationService=new SalutationService(); salutationService.salute(new GentsSalutation()); salutationService.salute(new LadiesSalutation()); &#125;&#125; We test it..and it does work.This looks much better. Now our SalutationService has a method that receives a Salutation object. Each Salutation object will have it’s own implementation of how to perform the salutation, so we can now create classes for whatever type of salutation we may need in the future. As long as the class implements the Salutation interface, we are good to go. We’re happy. Job Done. We head for the weekend for a deserved rest after such a tremendous amount of work. While by the pool drinking a Margarita , we start wondering that what we’ve done, was indeed a tremendous amount of work. Creating a lot of classes just for transporting around the action of performing a salutation, based on the gender. Ah..if we could only transport around the action directly, without the need to create a class, wouldn’t that be great ? By now the margarita takes effect and we fell asleep dreaming with passing around actions and behaviors in Java code without the need to create all those extra classes. Welcome to Lambda expressionsLambda expressions allow us to create independent entities (by independent, I mean they do not belong to a class) which we will call functions. And the best thing is that we can treat them as values, so we can pass them around. Those entities are simply blocks of code. Wait…are we talking about attributing a block of code to a variable ? Like variableName={ ... ...some Java code ... } Yes we are. That is the main idea behind a lambda expression (function), and now we are going to examine how we can transform a method into a function. If we take our previous example and apply to it what I’ve just said than what we want would be something like, gentsSalutation=public void perform () { System.out.println(“Hello dear sir&quot;); } But how can we do that ? How is a lambda expression formed ? A lambda expression is formed by getting rid of everything we do not need until we get the most concise unit of code that can actually perform the action we want. Let’s focus on the block of code that we’ve assigned above to the gentsSalutation variable. gentsSalutation=public void perform () { System.out.println(“Hello dear sir\"); } Does the keyword public makes any sense here ? This is not a method in a class, so the access modifier does not makes any sense. All we want is to condense the code to it’s core functionality. So we get rid of the modifier, and we now have, gentsSalutation=void perform () { System.out.println(“Hello dear sir\"); } Wait..we now have two names.. the variable name gentsSalutation and the method name perform. It is quite obvious that we want to refer to this piece of code by the variable name gentsSalutation. So the method name is redundant. Off it goes, and now we get gentsSalutation= void () { System.out.println(“Hello dear sir\"); } By now we are in a code deleting spree… Do we need void ? We know that void its the return type, but Java 8 compiler has become quite smart and it can now infer the return type just by looking at our code. In this case, our code doesn’t return anything, the Java 8 compiler understands that…Great..let’s get rid of it. gentsSalutation= () { System.out.println(“Hello dear sir\"); } Fantastic..What about the () ? Well, those we need. In our extremely simple example, we are not passing any parameters to the function, but we can do that, and we will see how to do that…later. For now, we can say that we have isolated the bare minimum piece of code that performs the action we want. For Java to understand that we want to use a lambda expression we need to add an extra element, and that is the element that identifies a lambda. The - &gt; By adding it to expression it becomes, gentsSalutation= () -> { System.out.println(“Hello dear sir\"); } Lambdas also have some syntactic rules, and some of them allow us to condense even further our code. Let’s now introduce the rule Number 1 If the code between the curly braces is only one line, then we can get rid of the curly braces. By applying that rule we end up with gentsSalutation= () -> System.out.println(“Hello dear sir\"); And there you go. This are the basics of how lambda expressions are formed. • Take a method.• Remove the access modifier.• Remove the name of the method.• Remove the return type.• add the -&gt; to identify this is a lambda expression.• Remove the curly braces if the block of code only has one line. It may take some time for our minds to get used to write lambda expressions directly. As you have seen there is no black magic of rocket science in that. It’s just a different approach of what we where used to do. But Wait…This does not work in Java !!!!! What is the type of the gentsSalutation variable ??? We will see that in my next post, where I will introduce Functional Interfaces. happy coding.","categories":[{"name":"Java Language","slug":"Java-Language","permalink":"https://jtmmartins.github.io/categories/Java-Language/"},{"name":"Lambda Expressions","slug":"Java-Language/Lambda-Expressions","permalink":"https://jtmmartins.github.io/categories/Java-Language/Lambda-Expressions/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"}]},{"title":"Prototype Pattern","slug":"Prototype-Pattern","date":"2017-12-22T20:36:31.000Z","updated":"2018-01-08T02:05:06.000Z","comments":true,"path":"2017/12/22/Prototype-Pattern/","link":"","permalink":"https://jtmmartins.github.io/2017/12/22/Prototype-Pattern/","excerpt":"","text":"Whenever object instantiation implies a high computational cost or an uncertain availability of data, we should consider the possibility of cloning, as it may be cheaper than creating brand new instances. Let us imagine an object that, while being initialized, calls a remote server to get some data for some of it’s attributes. Let’s also imagine that particular data changes only once every day at exactly midnight. Finally let’s pretend our system, needs to create one of those objects for each user and has an average of five hundred users per minute. When we imagine a situation as described, some challenges immediately come up. We will need to make a call to a remote server around five hundred times per minute, which will increase the traffic on our network and put some strain in the database. What if the server on the other side does not respond ? In a situation like this, instantiating objects can either become expensive (1), or become impossible, if the data source becomes unavailable (2). This is where the prototype pattern comes in. We instantiate one object, store that object, and re-use it by making copies of it, keeping the original untouched. Java actually made it very simple by providing us the Cloneable interface. Is that all ?Yes and No. When our object contains other objects inside, creating a copy of it has a pitfall we need to account for: we may need to clone the object and also all the objects inside. This introduces us to the concepts of shallow copy and deep copy and depending on our objective, we need to choose which method we want to implement. Shallow copyShallow copy is the standard way in Java when we use the Cloneable interface. In a shallow copy we will receive a new object which is a precise copy of the original. This means that if an object has other objects inside, when we change one of the inner objects all copies (clones) will be affected. in other words, the cloned object is a new object, but inner objects of the copy are exactly the same as in the original. Deep copyDeep copy method will provide us with a new object(the clone), maintaining the structure of the original object replicating it, but all inner objects will also be new. In this case, all inner objects will be independent, so any changes on them will only affect the particular object being altered and not all of them. Obviously that deep copy involves a higher cost, as it has to instantiate all the inner objects of the original as well as copy their exact states, so depending on what we want to achieve we should dedicate some time to examine the situation. In this article we will use an example that relies on primitives, so shallow copy will work perfectly. The exampleWe will be creating a board game. For our board game we have three heroes (an Elf, a Wizard, and a Goblin). We will pretend that to instantiate our heroes, we need to read some values from a database as health, magic, attack and defense values. If our board is initialized with 10 of each hero, we would need to fetch values from the database several times…not a good idea…So we clone. A simple UML representation of the prototype pattern for our case could be In the above representation, Hero is the interface that will act as an contract for all heroes. Goblin, Elf and Wizard are the classes that define them, and we have a HeroWareHouse, that will be used to store one hero of each. Those will be our “master” copy for each one (remember that we are pretending that for each of them we are reading values from a database) We will be using an UUID object to identify each hero. Some attention will be needed on that attribute, as each hero, will need to have a different UUID. We will be using a support enumerator, which will act as the database for the heroes properties. HeroProperties.java123456789101112131415161718192021222324package Prototype.Shallow;public enum HeroProperties &#123; ELF_ATTACK(60), ELF_DEFENSE(80), ELF_MAGIC(32), GOBLIN_ATTACK(75), GOBLIN_DEFENSE(80), GOBLIN_MAGIC(32), WIZARD_ATTACK(75), WIZARD_DEFENSE(80), WIZARD_MAGIC(32); private final int value; HeroProperties(int value) &#123; this.value = value; &#125; public int getValue() &#123; return value; &#125;&#125; The Hero Interface, will extend Cloneable from the JAVA API. We could actually implement the Cloneable interface directly in each of the heroes classes but would make our code more complicated as having a common type to handle our Heroes simplifies our work. Hero.java123456789package Prototype.Shallow;import java.util.UUID;public interface Hero extends Cloneable&#123; void setID(UUID heroID); Hero clone() throws CloneNotSupportedException;&#125; Now we have the three Hero classes. In our little example they are very similar. For simplicity we harcoded the health value as 100 for all of them. In the Hero classes we override the clone method, and please do note, that due the implementation we’ve used, we do need to cast the cloned object to the proper type before returning it.In the event that our object can’t be cloned, we will return a null object. Although returning nulls is never a good solution, and could be swapped by the Java Optional, we will leave it as is for the sake of simplicity, and we do not even check for nulls later…(I, know..don’t crucify me) Elf.java12345678910111213141516171819202122232425262728293031323334353637383940414243package Prototype.Shallow;import java.util.UUID;public class Elf implements Hero &#123; UUID heroID; int attack; int defense; int magic; int health; public Elf() &#123; this.attack = HeroProperties.ELF_ATTACK.getValue(); this.defense = HeroProperties.ELF_DEFENSE.getValue(); this.magic = HeroProperties.ELF_MAGIC.getValue(); this.health = 100; &#125; @Override public void setID(UUID heroID) &#123; this.heroID = heroID; &#125; @Override public Elf clone() throws CloneNotSupportedException &#123; try &#123; return (Elf) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public String toString() &#123; return \"Elf&#123;\" + \"attack=\" + attack + \", defense=\" + defense + \", magic=\" + magic + \", health=\" + health + '&#125;'; &#125;&#125; The Goblin class definition Goblin.java1234567891011121314151617181920212223242526272829303132333435363738394041package Prototype.Shallow;import java.util.UUID;public class Goblin implements Hero &#123; UUID heroID; int attack; int defense; int magic; int health; public Goblin()&#123; this.attack= HeroProperties.GOBLIN_ATTACK.getValue(); this.defense= HeroProperties.GOBLIN_DEFENSE.getValue(); this.magic= HeroProperties.GOBLIN_MAGIC.getValue(); this.health=100; &#125; @Override public void setID(UUID heroID) &#123; this.heroID = heroID; &#125; @Override public Goblin clone() throws CloneNotSupportedException &#123; try &#123; return (Goblin) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public String toString() &#123; return \"Goblin&#123;\" + \"attack=\" + attack + \", defense=\" + defense + \", magic=\" + magic + \", health=\" + health + '&#125;'; &#125;&#125; and finally the wizard Wizard.java123456789101112131415161718192021222324252627282930313233343536373839404142package Prototype.Shallow;import java.util.UUID;public class Wizard implements Hero &#123; UUID heroID; int attack; int defense; int magic; int health; public Wizard() &#123; this.attack= HeroProperties.WIZARD_ATTACK.getValue(); this.defense= HeroProperties.WIZARD_DEFENSE.getValue(); this.magic= HeroProperties.WIZARD_MAGIC.getValue(); this.health=100; &#125; @Override public void setID(UUID heroID) &#123; this.heroID = heroID; &#125; @Override public Wizard clone() throws CloneNotSupportedException &#123; try &#123; return (Wizard) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public String toString() &#123; return \"Wizard&#123;\" + \"attack=\" + attack + \", defense=\" + defense + \", magic=\" + magic + \", health=\" + health + '&#125;'; &#125;&#125; With the above in place, we go to the HeroWareHouse, which will act as a container of the Heroes “embryos”.The warehouse is a simple hash map, and as we will only be storing one hero of each, the class name is used as the key. Not very sophisticated, but it does serves the purpose. :) HeroWareHouse.java12345678910111213141516171819package Prototype.Shallow;import java.util.HashMap;import java.util.Map;public class HeroWarehouse &#123; private static Map&lt;String, Hero&gt; heroShop=new HashMap&lt;&gt;(); public Hero add(Hero hero)&#123; String className = hero.getClass().getSimpleName(); heroShop.put(className,hero); return heroShop.get(className); &#125; public Hero get(String Herotype)&#123; return heroShop.get(Herotype); &#125;&#125; The game board will be a 20 x 20 grid represented by a two-dimensional array. Whenever an Hero is added a new UUID for that hero will be generated. A simple while loop is used to ensure that the square is empty, so that no Hero is overwritten. Board.java1234567891011121314151617181920212223242526272829303132333435363738394041package Prototype.Shallow;import java.util.Random;import java.util.UUID;public class Board &#123; private static Hero[][] board= new Hero[20][20]; private static Random rand=new Random(); public Hero add (Hero hero)&#123; int x=0,y=0; boolean positionAvailable=false; while(positionAvailable==false) &#123; x=randomX(); y=randomY(); positionAvailable=isEmpty(x,y); &#125; hero.setID(UUID.randomUUID()); board[x][y]=hero; return board[x][y]; &#125; public int randomX()&#123; return rand.nextInt(21); &#125; public int randomY()&#123; return rand.nextInt(21); &#125; public boolean isEmpty(int x, int y)&#123; if (board[x][y]==null)&#123; return true; &#125; return false; &#125;&#125; So a little app to test all this HeroWareHouse.java1234567891011121314151617181920212223242526package Prototype.Shallow;public class App &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; HeroWarehouse heroWarehouse = new HeroWarehouse(); Hero elf = new Elf(); Hero goblin = new Goblin(); Hero wizard = new Wizard(); heroWarehouse.add(elf); heroWarehouse.add(goblin); heroWarehouse.add(wizard); Board gameboard = new Board(); for (int i = 0; i &lt;= 5; i++) &#123; gameboard.add(heroWarehouse.get(\"Wizard\").clone()); gameboard.add(heroWarehouse.get(\"Goblin\").clone()); gameboard.add(heroWarehouse.get(\"Elf\").clone()); &#125; &#125;&#125; As said earlier in this article, we are pretending that heroes values are being fetched from a database. So, we instantiate just one of each hero (Elf,Goblin and wizard), and store one copy of each in the heroWarehouse. Then after instantiating the game board, we fetch the heroes from the warehouse, and clone them, thus avoiding to repeat the process of fetching values from the database(here an imaginary one) We will come back to the prototype pattern, in another article with an example of deep copy cloning. An example for the code in this article can be found in git-hub","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"Hibernate - Auto-import Sample Data","slug":"Hibernate-Auto-import-Sample-Data","date":"2017-12-09T19:21:58.000Z","updated":"2018-04-21T13:29:25.000Z","comments":true,"path":"2017/12/09/Hibernate-Auto-import-Sample-Data/","link":"","permalink":"https://jtmmartins.github.io/2017/12/09/Hibernate-Auto-import-Sample-Data/","excerpt":"","text":"In early stages of a project, it is very common to have the need to produce tests against a consistent set of data. Knowing exactly what to expect from our database queries, simplifies our life. There are several utilities out there to assist us on the task as datafactory, but some times they don’t fit our exact needs, as not generating data in our language or forcing us to include code in our application tests (to be deleted later), that we do not want to. It comes up, that if we are using the Hibernate ORM framework, a very handy feature is included, that will automatically run a SQL Script every time we run our app. All we need to do is properly set-up our persistence.xml file. Persistence.xml is a standard JPA configuration file, and it has to be included in the META-INF folder of the jar where our entities classes live. Usually this refers to /src/main/resources/META-INF/persistence.xml This is where we define all the configurations so that Hibernate (or any other JPA compliant ORM) knows which database it should work with, username, password, etc. This is also where we should place a reference to all our entity classes. let’s look at an example of the Persistence.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"2.1\" xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\"&gt; &lt;persistence-unit name=\"testDB\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;class&gt;dbexperiment.User&lt;/class&gt; &lt;class&gt;dbexperiment.Product&lt;/class&gt; &lt;properties&gt; &lt;property name=\"hibernate.cache.provider_class\" value=\"org.hibernate.cache.NoCacheProvider\"/&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"org.hsqldb.jdbcDriver\"/&gt; &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.HSQLDialect\"/&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:hsqldb:mem:testDB;shutdown=true\"/&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"SA\"/&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"\"/&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\"/&gt; &lt;property name=\"javax.persistence.sql-load-script-source\" value=\"META-INF/import.sql\"/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; We are using hsqldb configured as an in-memory database. This is handy in early stages, as it is blazing fast and supports a wide range of SQL standard features, but what really matter for the purpose of this post are the properties defined in lines _16_ and _17_. In line _16_ we set the value of Data definition Language (DDL) to Create. This means, that when our application starts, it will scan the entity classes defined in the file and will create the correspondent tables in our database, actually dropping them if they previously existed. This ensures that the tables will be created exactly as defined in our entities anotations. (in the above example we have indicated that class User and Product of the package dbExperiment are entity classes) In line _17_ we have the magic property javax.persistence.sql-load-script-source that will load and execute the SQL script file. All we need to do is place the file import.sql in the indicated folder, and voilá..Every time we run our application, Hibernate will take care of creating the tables and executing the SQL script. An example import.sql file, could be something like , 1234567891011INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user1', 'user1@test.com');INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user2', 'user2@test.com');INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user3', 'user3@test.com');INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user4', 'user4@test.com');INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user5', 'user5@test.com');INSERT INTO User (user_id, user_name, email) VALUES(NULL, 'user7', 'user6@test.com');INSERT INTO Product (product_id, product_name) VALUES (NULL, 'product_1');INSERT INTO Product (product_id, product_name) VALUES (NULL, 'product_2');INSERT INTO Product (product_id, product_name) VALUES (NULL, 'product_3');INSERT INTO Product (product_id, product_name) VALUES (NULL, 'product_4'); We do not use create or drop statements in the example SQl script, because we’ve delegated that task to Hibernate, although we could set the DDL property to none, and then include in the SQL script the statements for dropping and create our tables. Do we need to mention all our Entity classes ?Actually, no. We can make use of another interesting property hibernate.archive.autodetection, which will instruct Hibernate which elements will be auto discovered by Hibernate Entity Manager. By changing the above Persistence.xml file to, 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"2.1\" xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\"&gt; &lt;persistence-unit name=\"testDB\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;properties&gt; &lt;property name=\"hibernate.archive.autodetection\" value=\"class, hbm\"/&gt; &lt;property name=\"hibernate.cache.provider_class\" value=\"org.hibernate.cache.NoCacheProvider\"/&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"org.hsqldb.jdbcDriver\"/&gt; &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.HSQLDialect\"/&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:hsqldb:mem:testDB;shutdown=true\"/&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"SA\"/&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"\"/&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\"/&gt; &lt;property name=\"javax.persistence.sql-load-script-source\" value=\"META-INF/import.sql\"/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; In this case we are specifying in line _6_ that our entities will be defined in class files and hbm files (Hibernate Mapping files), so it will scan for both). This is quite helpful, as forgetting to declare a entity class in Persistence.xml is quite common, so as long as your entities are defined in the same JAR where Persistence.xml is located and properly annotated the auto-scan property is a plus. However, if we’re not using auto detection, then we do need to include all our entity classes in Persistence.xml. You can find a very simple working example with two entities in this git-hub link.","categories":[{"name":"Frameworks","slug":"Frameworks","permalink":"https://jtmmartins.github.io/categories/Frameworks/"},{"name":"Hibernate","slug":"Frameworks/Hibernate","permalink":"https://jtmmartins.github.io/categories/Frameworks/Hibernate/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://jtmmartins.github.io/tags/Hibernate/"}]},{"title":"Decorator Pattern","slug":"Decorator-Pattern","date":"2017-12-01T19:14:46.000Z","updated":"2018-04-24T21:51:20.000Z","comments":true,"path":"2017/12/01/Decorator-Pattern/","link":"","permalink":"https://jtmmartins.github.io/2017/12/01/Decorator-Pattern/","excerpt":"","text":"The Decorator allow us to attach additional responsibilities to an object. The concept behind this pattern is not difficult to understand, as long as we have already understood other fundamental concepts as inheritance and composition. Let’s start simpleA decorator is like a shell. In objectland this translates to an object that holds another object inside. When we want to “talk” with the inner object, first we “talk” with the outer object, which acts as an intermediary. The outer object will then pass the message to the inner object. By using this “middleman” technique, we can intercept the messages that are sent to, or sent by, the inner object. If we can intercept them, it becomes obvious that we can manipulate them according to our needs. Can a Decorator decorate a Decorator ?It surely can, and that’s when things become interesting. An image will help to illustrate, Initial situation : Assembled situation : In a situation as the one in the image, when we want to reach object X, we first need to communicate with object C (decorator C), which will pass the message to object B (decorator B), which will pass the message to object A (decorator A), and finally it will arrive to object X. Any reply from the object X, will follow the inverse path, and along the way we can manipulate the “conversation” How do we build this structure ?To achieve this object structure, we will have to make sure that the object and the decorators are all of the same type. An Interface will help us on that. As all the objects are of the same type, we can “communicate” with the outer object as if we where dealing with the most inner object. Our exampleWe’ve just started our internet text messaging company. We provide our users with 3 service plans. A free one, that allows them to send plain text messages, a 1 dollar plan that allows them to send encrypted messages and a 2 dollar plan that will add an extra encryption layer to the messages. In our example, the simple encryption is represented by reversing the message, and the extra security layer is represented by codding the reversed message in Base64. This “highly sophisticated encryption” systems :) will be implemented in a class named Enigma. This example can illustrate the way we can play with decorators, combining them to achieve different results. The UML for our example, We will implement a Message interface, which will allow us to group our objects under the same type. We will only need one method for this interface that will be sendMessage() Message.java123456package DecoratorPattern.ExampleTWO;public interface Message &#123; void sendMessage(String message); &#125; Now we will implement the MessageDecorator, as an abstract class. All other decorators will derive from this class by extending it, and the behaviour will be defined in each decorator subclass. Message.java1234567891011121314151617181920package DecoratorPattern.MessageExample;public abstract class MessageDecorator implements Message &#123; protected Message decoratedMessage; public MessageDecorator(Message message) &#123; this.decoratedMessage = message; &#125; public abstract void sendMessage(String message); public Message getDecoratedMessage() &#123; return this.decoratedMessage; &#125;&#125; Next, we will implement our classes. One for each type of message. The plain text message StandardMessage Class, will act as the base object ( the one that will be decorated according to our needs). This base class will implement the Message Interface directly. StandardMessage.java12345678910package DecoratorPattern.MessageExample;public class StandardMessage implements Message &#123; @Override public void sendMessage(String message) &#123; System.out.println(\"Messag to send :\"); System.out.println(message + \"\\n\"); &#125;&#125; And now, we implement the decorators which will be the ReversedMessage and EncriptedMessage classes. Both will extend MessageDecorator and by being subclasses, they will have access to parent’s methods. ReversedMessage.java123456789101112131415package DecoratorPattern.MessageExample;public class ReversedMessage extends MessageDecorator &#123; public ReversedMessage(Message message) &#123; super(message); &#125; @Override public void sendMessage(String message) &#123; Enigma enigma = new Enigma(); String reversedMessage = enigma.reverser(message); this.getDecoratedMessage().sendMessage(reversedMessage); &#125;&#125; EncriptedMessagejava123456789101112131415package DecoratorPattern.MessageExample;public class EncriptedMessage extends MessageDecorator &#123; public EncriptedMessage(Message message) &#123; super(message); &#125; @Override public void sendMessage(String message) &#123; Enigma enigma = new Enigma(); String enigmatedMessage = enigma.B64Encode(message); this.getDecoratedMessage().sendMessage(enigmatedMessage); &#125;&#125; Finally we implement the Enigma class, which is a helper class that takes care of the our “super secure” encryption system. :) EncriptedMessagejava123456789101112131415161718192021222324package DecoratorPattern.MessageExample;import java.util.Base64;public class Enigma &#123; /** * codes the message in B64 */ public String B64Encode(String messageToEncrypt) &#123; byte[] bytesEncoded = Base64.getEncoder().encode(messageToEncrypt.getBytes(); return new String(bytesEncoded); &#125; /** * Inverts a string * abc -&gt; cba */ public String reverser(String messageToReverse) &#123; return new StringBuilder(messageToReverse).reverse().toString(); &#125;&#125; Let’s playWith our classes in place, we can now start to play with them and by combining decorators we can achieve interesting results. Sending a plain text message is straightforward. All we need to do is to instantiate a new StandardMessage and call the sendMessage method. 123String messageToSend = \"This is an important message about the decorator pattern\";Message message = new StandardMessage();message.sendMessage(messageToSend); When we want to decorate a message, is just a question of instantiating the kind of message we want to send, passing as argument either the base object or another decorator. So, if we want to send a Base64 encrypted message , 123String messageToSend = \"This is an important message about the decorator pattern\";Message encodedMessage = new EncriptedMessage(new StandardMessage());encodedMessage.sendMessage(messageToSend); and for a reversed message, 123String messageToSend = \"This is an important message about the decorator pattern\";Message reversedMessage = new ReversedMessage(new StandardMessage());reversedMessage.sendMessage(messageToSend); In this case we can play even further. If we want to send an Base64 encrypted reversed message, we can instantiate an EncriptedMessage passing as argument a ReversedMessage with a StandardMessage as argument. 123String messageToSend = \"This is an important message about the decorator pattern\";Message encodedAndReversedMessage = new EncriptedMessage(new ReversedMessage(new StandardMessage()));encodedAndReversedMessage.sendMessage(messageToSend); We can do another combination, reversing the message first and Base64 encoding it next, and that would become, 123String messageToSend = \"This is an important message about the decorator pattern\";Message reversedAndEncoded = new ReversedMessage(new EncriptedMessage(new StandardMessage()));reversedAndEncoded.sendMessage(messageToSend); We can even be crazy enough to double reverse a message, although that is useless, as we will get the initial message, but in an experiment there is nothing like being crazy, 123String messageToSend = \"This is an important message about the decorator pattern\";Message doubleReversed = new ReversedMessage(new ReversedMessage(new StandardMessage()));doubleReversed.sendMessage(messageToSend); And this are the basics of the Decorator pattern. A very interesting alternative to sub-classing, that allow us to combine things in very creative ways. An example for the code in this article can be found in git-hub Happy coding.","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"Introduction to factories","slug":"Simple-Factory","date":"2017-11-28T22:32:43.000Z","updated":"2017-12-09T19:20:27.000Z","comments":true,"path":"2017/11/28/Simple-Factory/","link":"","permalink":"https://jtmmartins.github.io/2017/11/28/Simple-Factory/","excerpt":"","text":"This post is an introduction to factories, and we will try to implement a very simple situation, that will allow us to better understand what factories do. It’s by no mean the best factory implementation, and it does not intends to be, however due to it’s simplicity it will help us to illustrate the idea. More complex factories will be discussed in other posts. So, why factories ?The factory pattern is used when we need to create an object but we will only know what kind of object to create during run time. There are different ways to implement factories, and the option to choose one of them depends on the problem we want to solve, but they all share the same advantages : Hiding the implementation logic behind object creation. All implementation logic is removed from the client code. we can change the logic of an object creation without touching the client code. we code for interface rather than implementation. The above advantages make our code less coupled and easier to maintain. What is the main idea ?In the real world, a factory produces goods according to market needs. Here, we are in objectland, so a factory will produce objects according to our requests, which may vary during the application run-time. To illustrate our example we will try to solve the following problem : Our application needs to implement a system that will send messages to our company customers, however we want to be able to send three different type of messages, Email, SMS and Fax (OK, I agree fax is old stuff, but we will use it anyway). Depending on some kind of input, that we will only know at run-time, our application has to be able to decide which kind of message to send. Examining our problemThe very first impulse, for a non object oriented mind will be a bunch of _if_ statements, based on that input, and job done. After all, its only 3 different type of messages !! What if… Next week we need to implement two more type of messages ? We will need to change all our code, and we will be facing, what I like to call an if farm, and we are half way to spaghetti code paradise. So, it does not look a very good idea. This is the kind of problem that the factory pattern proposes to solve. A better approachIf we look with an object oriented mind to the problem, we will spot a common element. They are all messages, only the way they are sent varies. Grouping them in a message interface seems a good starting point. Knowing that, we can then implement an message interface, with the single method SendMessage. Next we will write a class for each type of message, that will implement the message interface. In each of those classes we will then proceed with the actual implementation of the SendMessage method In UML our very simple factory will look like this Coding the UML visualizationThe Message interface Message.java123456package FactoryPatternSimple;public interface Message &#123; void sendMessage(String message);&#125; The three message classes Email.java123456789package FactoryPatternSimple;public class Email implements Message &#123; @Override public void sendMessage(String message) &#123; System.out.println(\"I'm sending an Email with the text : \" + message); &#125;&#125; SMS.java123456789package FactoryPatternSimple;public class SMS implements Message &#123; @Override public void sendMessage(String message) &#123; System.out.println(\"I'm sending an SMS with the text : \" + message); &#125;&#125; Fax.java123456789package FactoryPatternSimple;public class Fax implements Message &#123; @Override public void sendMessage(String message) &#123; System.out.println(\"I'm sending an FAX with the text : \" + message); &#125;&#125; In our UML diagram, we have the MessageType Enumerator. We will use it in our client code to select the type of message we want to send. We could pass Strings, but that would increase the possibility of typing errors, so the Enum, is safer. MessageType.java1234567package FactoryPatternSimple;public enum MessageType &#123; FaxMessage, SMSMessage, EmailMessage&#125; We now have the building blocks of our factory. The way I will use in this example to illustrate the factory implementation, is a very simple approach, but my intention is to introduce the concept of what a factory does, and in my humble opinion this makes the concept easier to understand. When we discuss more complex implementations it will be simpler to understand what is happening. MessageFactory.java1234567891011121314151617181920212223package FactoryPatternSimple;public class MessageFactory &#123; public Message construct(MessageType type) &#123; switch (type) &#123; case SMSMessage: return new SMS(); case EmailMessage: return new Email(); case FaxMessage: return new Fax(); &#125; throw new NullPointerException(\"Invalid Message Type\"); &#125;&#125; With the interface and classes in place, we can now very easily receive the object we want to send our messages. A very simple app will do to try it out. App.java12345678910111213141516171819202122package FactoryPatternSimple;package FactoryPatternSimple;public class App &#123; public static void main(String[] args) &#123; String messageText = \" This is a message from our company. Many thanks\"; MessageType type = MessageType.SMSMessage; Message messageSender = new MessageFactory().construct(type); messageSender.sendMessage(messageText); type = MessageType.EmailMessage; messageSender = new MessageFactory().construct(type); messageSender.sendMessage(messageText); type = MessageType.FaxMessage; messageSender = new MessageFactory().construct(type); messageSender.sendMessage(messageText); &#125;&#125; I believe this is will help to grasp the concept behind factories, and when we discuss more complex types of factories everything will look much easier. An example for the code in this article can be found in git-hub Happy Coding.","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"The builder Pattern, make it semantic","slug":"Builder-Pattern","date":"2017-11-28T11:47:37.000Z","updated":"2017-12-09T23:10:27.000Z","comments":true,"path":"2017/11/28/Builder-Pattern/","link":"","permalink":"https://jtmmartins.github.io/2017/11/28/Builder-Pattern/","excerpt":"","text":"The purpose of the builder pattern is to simplify the construction of complex objects, providing us a method to create different representations by using the same construction process. It’s not uncommon to create objects that need to receive lots of arguments to be properly initialized and in a usable state. There are at least two ways to achieve this. We can Use a parametrized constructor or we can use setters. Let’s see the problems that can arise from this “standard” way to do things. The constructor problemlet’s imagine you are examining some code and come across a line like, Window window = new Window (100,100,200,300,&quot;settings&quot;,35,127,32) What information do you get from there ? What are all those values for ? We don’t know, so, although the IDE may help a little here, we normally end up visiting the Window class, just to make sure. It may be simple, and surely works, but the true is that an extra layer of complexity was inserted in this code, as it is not easily understandable. The setter’s problemAlthough using setters will overcome the problem of us not knowing what the values refer to, there is a severe hidden problem. To access the setters, we first need to instantiate the object, and that means that the object already exists somewhere in the heap, but until we have all the setters “properly setted”, the object is in an inconsistent state. Using it, before it is fully formed, may lead to unpredictable results. In some applications, this is a disaster waiting to happen. There must be a better way, and that’s where the builder pattern comes in. The idea is to build our object, step by step, and in the end we will receive the object fully formed. The steps we will use will be, Create a class that represents our object with all the needed attributes. Create a static inner class an in this inner class we copy all the attributes of the outer class. Convention dictates that the inner class should be named as the outer class with the suffix builder. The builder class should have a public constructor with all attributes as parameters. In the inner class we should make available a public method named builder (again, this name is a convention) that will return our object. To properly achieve this we will use a private constructor in the outer class that will receive as argument it’s inner class. NOTE : we may have more than one builder class, each one with different steps to create the object. Here we are using the fact that in Java, a static inner class acts as a static member of the outer class, and it can be accessed without instantiating the outter class. After implementing a builder, the line we showed above as, Window window = new Window (100,100,200,300,&quot;settings&quot;,35,127,32) will become `Window window = new Window.WindowBuilder() .withLeftTopcornerPositionX(100) .withLeftTopCornerPositionY(100) .withHeight(300) .withWidth(600) .fillWithRGB(125,180,28) .withTitle(&quot;Settings&quot;) .build();` Now, besides coding, we are actually communicating in an elegant way. Anyone that comes across this code, will easily understand what it does. So, let’s see the implementation, Window.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package BuilderPattern;public class Window &#123; private final int topCornerX; private final int topCornerY; private final int windowWidth; private final int windowHeight; private final int fillRedValue; private final int fillGreenValue; private final int fillBlueValue; private final String windowTitle; // begin of inner class public static final class WindowBuilder &#123; private int topCornerX; //if nothing is said, default value will be zero private int topCornerY; //if nothing is said, default value will be zero // if no values are send to builder, this will be the default values private int windowWidth = 300; private int windowHeight = 300; private int fillRedValue = 255; private int fillGreenValue = 255; private int fillBlueValue = 255; private String windowTitle = \"untitled\"; public WindowBuilder withLeftTopcornerPositionX(int topCornerX) &#123; //we don't want our X coordinates out of this range if (isWithinRange(topCornerX, 0, 1024)) &#123; topCornerX = 0; &#125; this.topCornerX = topCornerX; return this; &#125; public WindowBuilder withLeftTopCornerPositionY(int topCornerY) &#123; //we don't want our Y coordinates out of this range if (isWithinRange(topCornerY, 0, 800)) &#123; topCornerY = 0; &#125; this.topCornerY = topCornerY; return this; &#125; public WindowBuilder withWidth(int windowWidth) &#123; //we don't want our width out of this range if (isWithinRange(windowWidth, 1, 600)) &#123; windowWidth = 300; &#125; this.windowWidth = windowWidth; return this; &#125; public WindowBuilder withHeight(int windowHeight) &#123; //we don't want our height out of this range if (isWithinRange(windowHeight, 1, 600)) &#123; windowHeight = 300; &#125; this.windowHeight = windowHeight; return this; &#125; public WindowBuilder fillWithRGB(int red, int green, int blue) &#123; //we don't want any of the RGB values out of the range (0-255) if ((isWithinRange(red, 0, 255) | (isWithinRange(green, 0, 255)) | (isWithinRange(blue, 0, 255)))) &#123; red = 255; green = 255; blue = 255; &#125; this.fillRedValue = red; this.fillGreenValue = green; this.fillBlueValue = blue; return this; &#125; public WindowBuilder withTitle(String title) &#123; if (title != null &amp;&amp; !title.equals(\"\")) &#123; this.windowTitle = title; &#125; else &#123; this.windowTitle = \" untitled \"; &#125; return this; &#125; public Window build() &#123; return new Window(this); &#125; /* * verifies if a value is out of accepted range */ private boolean isWithinRange(int value, int min, int max) &#123; return (value &lt; min || value &gt; max); &#125; &#125;// end of inner class public Window(WindowBuilder builder) &#123; this.topCornerX = builder.topCornerX; this.topCornerY = builder.topCornerY; this.windowHeight = builder.windowHeight; this.windowWidth = builder.windowWidth; this.fillRedValue = builder.fillRedValue; this.fillGreenValue = builder.fillGreenValue; this.fillBlueValue = builder.fillBlueValue; this.windowTitle = builder.windowTitle; &#125; @Override public String toString() &#123; return \"I'm creating a window with a name \" + windowTitle + \" top left X corner = \" + topCornerX + \" top left Y corner = \" + topCornerY + \" with a width of \" + windowWidth + \" and height of \" + windowHeight + \" I will fill the window with the color (\" + fillRedValue + \",\" + fillGreenValue + \",\" + fillBlueValue + \")\"; &#125; public int getTopCornerX() &#123; return topCornerX; &#125; public int getTopCornerY() &#123; return topCornerY; &#125; public int getWindowWidth() &#123; return windowWidth; &#125; public int getWindowHeight() &#123; return windowHeight; &#125; public int getFillRedValue() &#123; return fillRedValue; &#125; public int getFillGreenValue() &#123; return fillGreenValue; &#125; public int getFillBlueValue() &#123; return fillBlueValue; &#125; public String getWindowTitle() &#123; return windowTitle; &#125;&#125; Now, that may seems a lot of work, but trust me, it will pay off in the long run. An example for the code in this article can be found in git-hub","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"Hi there, I'm the Enum singleton","slug":"enum-singleton","date":"2017-11-26T22:07:20.000Z","updated":"2017-12-09T19:19:59.000Z","comments":true,"path":"2017/11/26/enum-singleton/","link":"","permalink":"https://jtmmartins.github.io/2017/11/26/enum-singleton/","excerpt":"","text":"Enum Singletons are probably the most secure way to implement this pattern in Java and are also much easier to write. By default, enums are themselves singletons and thread safe in Java, so this is already a plus, but we have another plus…Enum Singletons can be Serialized if needed without any further complications.The downside is that they are always instantiated at classload time, so they are eager initialized. Depending on the needs, the enum singleton can be a valid option. Implementing a enum singleton is straightforward 12345678910111213package Singleton.enumsingleton;public enum EnumEagerSingleton &#123; INSTANCE; public static String doSomeWork() &#123; System.out.println(\"EnumLazySingleton is Doing SomeWork\"); return \"EnumLazySingleton has finished Doing Work\"; &#125;&#125; what is going on in this class ?The above code is very straightforward. Please just note that in the doSomeWork() method we return a String just for the sake of the tests. An example for the code in this article can be found in git-hub","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"The eager singleton","slug":"eager-singleton","date":"2017-11-26T18:58:32.000Z","updated":"2017-12-09T19:19:48.000Z","comments":true,"path":"2017/11/26/eager-singleton/","link":"","permalink":"https://jtmmartins.github.io/2017/11/26/eager-singleton/","excerpt":"","text":"As mentioned in this post singletons can be instantiated in two different ways, and one of them is eager instantiation. Bellow we have an example of a class defining a singleton that will be eager instantiated. EagerSingleton.java12345678910111213141516package Singleton.eagersingleton;public class EagerSingleton &#123; private static final EagerSingleton Instance = new EagerSingleton(); private EagerSingleton() &#123;&#125; public static EagerSingleton getInstance() &#123; return instance; &#125; public void doSomeWork() &#123; System.out.println(\"EagerSingleton is doing some work\\n\"); &#125;&#125; In the above example, an instance of this object is created as soon as the JVM loads the class, so we should only use it if the needed computational resources are not extremely high. If they are, and we still believe that a singleton is the best option, than we should opt for the lazy instantiation. what is going on in this class ?As soon as the class is loaded the final attribute instance is instantiated in line 5. In line 7 we define the class constructor as private. This will prevent client code to instantiate the object via the new keyword. Due to this private constructor is not possible to use EagerSingleton egSingleton=new EagerSingleton. in order to get our instance we will need to call the static method on line 9, and that will return us the singleton object (which has been initialized at class loading time). After receiving an instance of the object, we can call all the public methods on it. An example for the code in this article can be found in git-hub Happy coding.","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]},{"title":"Design Patterns introduction","slug":"Patterns","date":"2017-11-25T21:17:34.000Z","updated":"2017-11-28T18:02:33.000Z","comments":true,"path":"2017/11/25/Patterns/","link":"","permalink":"https://jtmmartins.github.io/2017/11/25/Patterns/","excerpt":"","text":"When we arrive to the world of object oriented programming (OOP), one of the first terms we encounter is design patterns. Design patterns are important stuff, and we really need to understand them. As everything in life, some of these patterns are easier to understand than others, but as long as you have understood the principles of OOP as inheritance, composition , polymorphism and encapsulation and have your mind oriented to think in the “object way” you will be half way there. Design patterns are probably one of the most influential development strategies that came out of the minds behind the OOP thinkers and comes hand to hand with software reuse. So the first question we normally put to ourselves is : What are these Design Pattern things ?Design patterns represent the best practises to solve a particular type of problem, being that by best practises we refer to well documented, well tested and efficient solutions.In fact, when we have a well tested and efficient solution that can be applied and re - applied successfully to a certain kind of problem, we are facing a pattern. This can be applied not only to software, but to many other things in our human world. Who invented this stuff ?Well, the true is that there is no single master mind behind this design patterns, however we can consider the book Elements of reusable object oriented software as the milestone that has established the principles. Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides,the authors of the book, have in fact become so popular that they are referred as the Gang of Four or GOF. So, next time you ear someone talk about the GOF patterns, you know they are talking about the principles presented in those guys book. Why do I need to learn them ?We, as developers, need tools. By tools, here, we do not mean software tools, but knowledge that can allow us to carry out our job in the most efficient manner. So, if someone has invented an efficient way to solve a problem, we obviously should use it when we face the same kind of problem (unless, of course, we come up with a better solution). Another important aspect of Design Patterns is the fact that they supply us with an abstraction over a problem, allowing for a better communication between software developers. If one developer is trying to explain to his colleague all the steps he used to solve a particular problem, it may very well be a lengthy and confusing process. However if can reduce his explanations to something like, I’ve used a Flyweight here and an Observer there, then communication will be vastly improved. And that’s why we need to learn them. Because we want to solve our problems in the most efficient ways and we want to be able to communicate with our peers and understand what they are saying. Enough thoughts on the subject and let’s move on Design patterns usually fall into three categories : Creational Structural Behavioural Creational patternsThese are used to create objects for us. This means that instead of creating our own instances, we will request that objects are given to us, in the proper state, when we need them. This gives us an extra layer of flexibility, as the software itself may decide what kind of object to create for a given situation. Structural patternsAs the applications grow in complexity, so our objects complexity starts to grow. We will eventually arrive to a point where objects will need to be grouped together to form some complex data structures. Managing those complex data structures manually every time we need them, my become a very complex task. The structural patterns try to abstract away that complexity, so that we can work with complex objects in a easier way. Behavioural patternsThese patterns are responsible for the distribution of responsibilities amongst our objects, clearly defining how objects interact with each other,the flow of that communication and ensuring that the objects are loosely coupled. So, How many patterns do exist out there ?In one word , Many. In this article we will only name 23, which are those referred in the GOF book, however there are many more. As technology and development languages evolves, new problems appear, and new ways to solve those problems are found. Eventually those new ways become so popular, well documented and tested that they become a design pattern by their own right. The patterns mentioned in the GOF book are : Creational Abstract factory Builder Factory Method Prototype Singleton Structural Adapter Bridge Composite Decorator Facade Flyweight Proxy Behavioural Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template method Visitor In my devlog, I will try to explain and document all the above patterns. This is an ongoing project that I do in my free time, so stay tuned and comeback from time to time, to check out for new content.","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"},{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/tags/Architecture/"}]},{"title":"Singleton-A little theory","slug":"Singleton","date":"2017-11-25T16:59:04.000Z","updated":"2017-11-28T19:09:45.000Z","comments":true,"path":"2017/11/25/Singleton/","link":"","permalink":"https://jtmmartins.github.io/2017/11/25/Singleton/","excerpt":"","text":"Sometimes we need to make sure that we have only one instance of an object throughout the entire life-cycle of an application. There may be many reasons for that, but one of the most commons is to avoid overuse of computer resources. In the definition of the singleton design pattern there are two major points, There can only be one instance of an object at any given time. We should allow global point of access to that single instance. Singletons are very easy to understand, however when it comes to implementation several concerns start to appear. Imagine we are in a multithreaded environment and two different threads request instantiation at the same time. Although this may seem like a long shot, the true is that it happens and will probably break the application. What if someone decides to use reflection to access the Singleton’s private constructor ? This two points (and some others as Cloning or Serializing) have made the Singleton a controversial topic. So let’s dig a little this Singleton thing, How to instantiate a Singleton ?There are two ways to instantiate a Singleton, Lazy instantiation Eager instantiation Let’s see what this means, In eager instantiation, the singleton instance is created as soon as the JVM does the classload. In other words, even if we are not yet using the singleton, the resources that the object eventually needs are already being consumed. On the other hand, lazy instantiation will only consume the resources when we actually instantiate the singleton for the first time. Although lazy instantiation is preferred we need to take some additional care if we decide to go for it, as while the eager instantiation is thread safe the lazy instantiation is not, and we will need to ensure it get’s synchronized. We’re in Java..can we use an Enum as a Singleton ?As Obama would say, Yes We Can.In Java, it happens that Enums are singletons by nature and are globally accessible, so that makes them a good candidate when we want to use a Singleton, however there are some drawbacks in terms of flexibility and instantiation will always be eager. How to represent a Singleton in UML ? Client code requests an instance of the singleton object by calling the getInstance() method. Note that Singleton constructor is private(-), and this will immediately invalidate the standard instantiation. Singleton singleon = new Singleton() will not compile. How do we test for Singletons ?In Java we know that if two objects have the same hash code then they refer to the same object, so we can use that to test if our code is doing what is supposed to do. Should we use Singletons ?This is where the controversial starts…My thoughts on singletons are quite practical. It depends. Nowadays, we have lots of IOT products with little computing power, little resources and several controllers. We need to communicate with these hardware controllers in the most efficient way in order to save resources and optimize speed. So Singletons may very well be suited for the situation. Never despise a programming technique, just because some people say it’s bad(actually you may find people that say that all design patterns are bad in general !!). Always give a little thought on the problem. Does it really need to be global ? Can we do it better ? If you opt to go for the singleton, and that will become problematic at a later stage…well, you can be sure that you will know it. :) In following articles we will visit some examples of the singleton pattern. You can follow the links bellow. Eager instantiation Singleton Enum Based Singleton","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://jtmmartins.github.io/categories/Architecture/"},{"name":"Design Patterns","slug":"Architecture/Design-Patterns","permalink":"https://jtmmartins.github.io/categories/Architecture/Design-Patterns/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jtmmartins.github.io/tags/Java/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://jtmmartins.github.io/tags/Design-Patterns/"}]}]}